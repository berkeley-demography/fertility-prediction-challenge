# Preprocess the input dataframe to feed the model.
### If no cleaning is done (e.g. if all the cleaning is done in a pipeline) leave only the "return df" command
df <- df %>%
# filter by whether outcome is available
filter(outcome_available == 1)
# Parameters:
# df (dataframe): The input dataframe containing the raw data (e.g., from PreFer_train_data.csv or PreFer_fake_data.csv).
# background (dataframe): Optional input dataframe containing background data (e.g., from PreFer_train_background_data.csv or PreFer_fake_background_data.csv).
# Returns:
# data frame: The cleaned dataframe with only the necessary columns and processed variables.
# identifying variables
fixed_covars <- c(
birthyear_bg = "Birth year of respondent; created and cleaned",
gender_bg = "Gender of respondent; created and cleaned",
# TODO - leave this out for now, b/c it is missing in some cases
#migration_background_bg = "Migration background of the respondent; created and cleaned",
age_bg = "The age of the respondent for each wave; created (not fixed, but records similar information as birthyear)"
)
varying_covars <- c(
"partner",
"woonvorm",
"burgstat",
"woning",
"sted",
"brutohh_f",
"nettohh_f",
"belbezig",
"brutoink",
"nettoink",
"oplzon",
"oplmet",
"oplcat",
"brutoink_f",
"netinc",
"nettoink_f"
)
covars <- c(
nomem_encr = "Number of household member encrypted",
nohouse_encr = "Number of household encrypted",
wave = "Year and month of the field work period",
positie = "Position within the household",
lftdcat = "Age in CBS (Statistics Netherlands) categories",
lftdhhh = "Age of the household head",
aantalhh = "Number of household members",
aantalki = "Number of living-at-home children in the household, children of the household head or his/her partner",
partner = "The household head lives together with a partner (wedded or unwedded)",
burgstat = "Civil status",
woonvorm = "Domestic situation",
woning = "Type of dwelling that the household inhabits",
belbezig = "Primary occupation",
brutoink = "Personal gross monthly income in Euros",
nettoink = "Personal net monthly income in Euros (incl. nettocat)",
brutocat = "Personal gross monthly income in categories",
nettocat = "Personal net monthly income in categories",
oplzon = "Highest level of education irrespective of diploma",
oplmet = "Highest level of education with diploma",
oplcat = "Level of education in CBS (Statistics Netherlands) categories",
doetmee = "Household member participates in the panel",
sted = "Urban character of place of residence",
simpc = "Does the household have a simPC?",
brutoink_f = "Personal gross monthly income in Euros, imputed",
netinc = "Personal net monthly income in Euros",
nettoink_f = "Personal net monthly income in Euros, imputed",
brutohh_f = "Gross household income in Euros",
nettohh_f = "Net household income in Euros",
werving = "From which recruitment wave the household originates",
birthyear_imp = "Year of birth [imputed by PreFer organisers] (based on original gebjaar variable)",
gender_imp = "Gender [imputed by PreFer organisers] (based on original geslacht variable)",
migration_background_imp = "Origin [imputed by PreFer organisers] (based on original herkomstgroep variable)",
age_imp = "Age of the household member [imputed by PreFer organisers] (based on original leeftijd variable)"
)
# Filtering dataframe by selected variables
simple_df <- df %>%
select(contains(names(fixed_covars)),
contains(varying_covars),
contains(covars),
nomem_encr) %>%
# some of the vars from 2007 were giving us grief, so
# we're not including them for now
select(-contains('2007'))
return(df)
}
# setwd("path to your local repository") # <---- provide the path here
# preprocessing the data
train_cleaned <- clean_df(train)
# training and saving the model
train_save_model(train_cleaned, outcome)
train_df <- train
outcome_df <- outcome
# only need to run once - loads the `score` fn
source("https://preferdatachallenge.nl/data/score.R")
fixed_covars <- c(
birthyear_bg = "Birth year of respondent; created and cleaned",
gender_bg = "Gender of respondent; created and cleaned",
# TODO - leave this out for now, b/c it is missing in some cases
#migration_background_bg = "Migration background of the respondent; created and cleaned",
age_bg = "The age of the respondent for each wave; created (not fixed, but records similar information as birthyear)"
)
varying_covars <- c(
"partner",
"woonvorm",
"burgstat",
"woning",
"sted",
"brutohh_f",
"nettohh_f",
"belbezig",
"brutoink",
"nettoink",
"oplzon",
"oplmet",
"oplcat",
"brutoink_f",
"netinc",
"nettoink_f"
)
covars <- c(
nomem_encr = "Number of household member encrypted",
nohouse_encr = "Number of household encrypted",
wave = "Year and month of the field work period",
positie = "Position within the household",
lftdcat = "Age in CBS (Statistics Netherlands) categories",
lftdhhh = "Age of the household head",
aantalhh = "Number of household members",
aantalki = "Number of living-at-home children in the household, children of the household head or his/her partner",
partner = "The household head lives together with a partner (wedded or unwedded)",
burgstat = "Civil status",
woonvorm = "Domestic situation",
woning = "Type of dwelling that the household inhabits",
belbezig = "Primary occupation",
brutoink = "Personal gross monthly income in Euros",
nettoink = "Personal net monthly income in Euros (incl. nettocat)",
brutocat = "Personal gross monthly income in categories",
nettocat = "Personal net monthly income in categories",
oplzon = "Highest level of education irrespective of diploma",
oplmet = "Highest level of education with diploma",
oplcat = "Level of education in CBS (Statistics Netherlands) categories",
doetmee = "Household member participates in the panel",
sted = "Urban character of place of residence",
simpc = "Does the household have a simPC?",
brutoink_f = "Personal gross monthly income in Euros, imputed",
netinc = "Personal net monthly income in Euros",
nettoink_f = "Personal net monthly income in Euros, imputed",
brutohh_f = "Gross household income in Euros",
nettohh_f = "Net household income in Euros",
werving = "From which recruitment wave the household originates",
birthyear_imp = "Year of birth [imputed by PreFer organisers] (based on original gebjaar variable)",
gender_imp = "Gender [imputed by PreFer organisers] (based on original geslacht variable)",
migration_background_imp = "Origin [imputed by PreFer organisers] (based on original herkomstgroep variable)",
age_imp = "Age of the household member [imputed by PreFer organisers] (based on original leeftijd variable)"
)
simple_df <- train_df %>%
select(contains(names(fixed_covars)),
contains(varying_covars),
nomem_encr) %>%
# some of the vars from 2007 were giving me grief, so
# I'm not including them for now
select(-contains('2007')) %>%
# we want the outcome
left_join(outcome_df, by=c('nomem_encr')) %>%
# TODO - why are some rows missing the outcome?
filter(! is.na(new_child)) %>%
mutate(new_child = as.factor(new_child))
set.seed(101319)
simple_df_split <- initial_split(simple_df, prop=0.8, strata=new_child)
simple_df_train <- training(simple_df_split)
simple_df_test <- testing(simple_df_split)
rec_obj <- recipe(new_child ~ ., data = simple_df_train) %>%
# the ID variable is not a predictor
remove_role(nomem_encr, old_role = 'predictor') %>%
update_role(nomem_encr, new_role = "ID")
rec_obj
imputed <- rec_obj %>%
step_impute_knn(all_predictors())
imputed
ind_vars <- imputed %>%
step_dummy(all_nominal_predictors())
ind_vars
standardized <- ind_vars %>%
step_center(all_numeric_predictors()) %>%
step_scale(all_numeric_predictors())
standardized
trained_rec <- prep(standardized, training = simple_df_train)
trained_rec
train_data <- bake(trained_rec, new_data = simple_df_train)
test_data <- bake(trained_rec, new_data = simple_df_test)
boosted_trees_model <-
boost_tree(trees=20) %>%
set_engine('xgboost') %>%
set_mode('classification')
boosted_trees_fit <-
boosted_trees_model %>%
fit(new_child ~ .,
data = train_data  %>%
select(-nomem_encr))
install.packages("xgboost")
boosted_trees_model <-
boost_tree(trees=20) %>%
set_engine('xgboost') %>%
set_mode('classification')
boosted_trees_fit <-
boosted_trees_model %>%
fit(new_child ~ .,
data = train_data  %>%
select(-nomem_encr))
View(boosted_trees_fit)
# setwd("path to your local repository") # <---- provide the path here
# preprocessing the data
train_cleaned <- clean_df(train)
# training and saving the model
train_save_model(train_cleaned, outcome)
test_data <- bake(trained_rec, new_data = simple_df_test)
# but the resulting model model.joblib will be applied to the holdout data.
#
# It is important to document your training steps here, including seed,
# number of folds, model, et cetera
train_save_model <- function(cleaned_df, outcome_df) {
# Trains a model using the cleaned dataframe and saves the model to a file.
# Parameters:
# cleaned_df (dataframe): The cleaned data from clean_df function to be used for training the model.
# outcome_df (dataframe): The data with the outcome variable (e.g., from PreFer_train_outcome.csv or PreFer_fake_outcome.csv).
# Combine cleaned_df and outcome_df
combined_df <- cleaned_df %>%
left_join(outcome_df, by=c('nomem_encr'))
# set seed
set.seed(101319)
simple_df_split <- initial_split(simple_df, prop=0.8, strata=new_child)
simple_df_train <- training(simple_df_split)
simple_df_test <- testing(simple_df_split)
# create recipe
rec_obj <- recipe(new_child ~ ., data = simple_df_train) %>%
# the ID variable is not a predictor
remove_role(nomem_encr, old_role = 'predictor') %>%
update_role(nomem_encr, new_role = "ID")
# impute missing
imputed <- rec_obj %>%
step_impute_knn(all_predictors())
ind_vars <- imputed %>%
step_dummy(all_nominal_predictors())
# normalize
standardized <- ind_vars %>%
step_center(all_numeric_predictors()) %>%
step_scale(all_numeric_predictors())
trained_rec <- prep(standardized, training = simple_df_train)
train_data <- bake(trained_rec, new_data = simple_df_train)
test_data <- bake(trained_rec, new_data = simple_df_test)
# set up XGBoost model
boosted_trees_model <-
boost_tree(trees=20) %>%
set_engine('xgboost') %>%
set_mode('classification')
boosted_trees_fit <-
boosted_trees_model %>%
fit(new_child ~ .,
data = train_data  %>%
select(-nomem_encr))
# Save the model
saveRDS(boosted_trees_fit, "model.rds")
}
# training and saving the model
train_save_model(train_cleaned, outcome)
# load the fake data
fake <- data.table::fread("PreFer_fake_data.csv",
keepLeadingZeros = TRUE, # if FALSE adds zeroes to some dates
data.table = FALSE)
# apply the function to the fake data
predict_outcomes(fake)
predict_outcomes <- function(df, background_df = NULL, model_path = "./model.rds"){
# Generate predictions using the saved model and the input dataframe.
# The predict_outcomes function accepts a dataframe as an argument
# and returns a new dataframe with two columns: nomem_encr and
# prediction. The nomem_encr column in the new dataframe replicates the
# corresponding column from the input dataframe The prediction
# column contains predictions for each corresponding nomem_encr. Each
# prediction is represented as a binary value: '0' indicates that the
# individual did not have a child during 2021-2023, while '1' implies that
# they did.
# Parameters:
# df (dataframe): The data dataframe for which predictions are to be made.
# background_df (dataframe): The background data dataframe for which predictions are to be made.
# model_path (str): The path to the saved model file (which is the output of training.R).
# Returns:
# dataframe: A dataframe containing the identifiers and their corresponding predictions.
## This script contains a bare minimum working example
if( !("nomem_encr" %in% colnames(df)) ) {
warning("The identifier variable 'nomem_encr' should be in the dataset")
}
# Load the model
model <- readRDS(model_path)
# Preprocess the fake / holdout data
df <- clean_df(df, background_df)
# Exclude the variable nomem_encr if this variable is NOT in your model
vars_without_id <- colnames(df)[colnames(df) != "nomem_encr"]
# Generate predictions from model
predictions <- predict(model,
subset(df, select = vars_without_id),
type = "prob")
# Create predictions that should be 0s and 1s rather than, e.g., probabilities
predictions <- ifelse(predictions > 0.5, 1, 0)
# Output file should be data.frame with two columns, nomem_encr and predictions
df_predict <- data.frame("nomem_encr" = df[ , "nomem_encr" ], "prediction" = predictions)
# Force columnnames (overrides names that may be given by `predict`)
names(df_predict) <- c("nomem_encr", "prediction")
# Return only dataset with predictions and identifier
return( df_predict )
}
predict_outcomes(fake)
predict_outcomes <- function(df, background_df = NULL, model_path = "./model.rds"){
# Generate predictions using the saved model and the input dataframe.
# The predict_outcomes function accepts a dataframe as an argument
# and returns a new dataframe with two columns: nomem_encr and
# prediction. The nomem_encr column in the new dataframe replicates the
# corresponding column from the input dataframe The prediction
# column contains predictions for each corresponding nomem_encr. Each
# prediction is represented as a binary value: '0' indicates that the
# individual did not have a child during 2021-2023, while '1' implies that
# they did.
# Parameters:
# df (dataframe): The data dataframe for which predictions are to be made.
# background_df (dataframe): The background data dataframe for which predictions are to be made.
# model_path (str): The path to the saved model file (which is the output of training.R).
# Returns:
# dataframe: A dataframe containing the identifiers and their corresponding predictions.
## This script contains a bare minimum working example
if( !("nomem_encr" %in% colnames(df)) ) {
warning("The identifier variable 'nomem_encr' should be in the dataset")
}
# Load the model
model <- readRDS(model_path)
# Preprocess the fake / holdout data
df <- clean_df(df, background_df)
# Exclude the variable nomem_encr if this variable is NOT in your model
vars_without_id <- colnames(df)[colnames(df) != "nomem_encr"]
# Generate predictions from model
predictions <- predict(model,
subset(df, select = vars_without_id),
type = "class")
# Create predictions that should be 0s and 1s rather than, e.g., probabilities
#predictions <- ifelse(predictions > 0.5, 1, 0)
# Output file should be data.frame with two columns, nomem_encr and predictions
df_predict <- data.frame("nomem_encr" = df[ , "nomem_encr" ], "prediction" = predictions)
# Force columnnames (overrides names that may be given by `predict`)
names(df_predict) <- c("nomem_encr", "prediction")
# Return only dataset with predictions and identifier
return( df_predict )
}
predict_outcomes(fake)
model <- readRDS("best_final_fit.rds")
View(model)
model_path = "./best_final_fit.rds"
model <- readRDS(model_path) %>% unbundle()
library(here)
library(tidyverse)
library(tidymodels)
library(bundle)
model <- readRDS(model_path) %>% unbundle()
View(model)
model <- readRDS("best_final_fit.rds")
model_path = "model.rds"
model <- readRDS(model_path)
knitr::opts_chunk$set(echo = TRUE)
# load the fake data
fake <- data.table::fread("PreFer_fake_data.csv",
keepLeadingZeros = TRUE, # if FALSE adds zeroes to some dates
data.table = FALSE)
# apply the function to the fake data
predict_outcomes(fake)
predict_outcomes <- function(df, background_df = NULL, model_path = "./best_final_fit.rds"){
# Generate predictions using the saved model and the input dataframe.
# The predict_outcomes function accepts a dataframe as an argument
# and returns a new dataframe with two columns: nomem_encr and
# prediction. The nomem_encr column in the new dataframe replicates the
# corresponding column from the input dataframe The prediction
# column contains predictions for each corresponding nomem_encr. Each
# prediction is represented as a binary value: '0' indicates that the
# individual did not have a child during 2021-2023, while '1' implies that
# they did.
# Parameters:
# df (dataframe): The data dataframe for which predictions are to be made.
# background_df (dataframe): The background data dataframe for which predictions are to be made.
# model_path (str): The path to the saved model file (which is the output of training.R).
# Returns:
# dataframe: A dataframe containing the identifiers and their corresponding predictions.
## This script contains a bare minimum working example
if( !("nomem_encr" %in% colnames(df)) ) {
warning("The identifier variable 'nomem_encr' should be in the dataset")
}
# Load the model
model <- readRDS(model_path) %>% unbundle()
df_predict <- predict(model, df) %>%
bind_cols(df %>% select(nomem_encr)) %>%
select(nomem_encr, prediction = .pred_class)
# Preprocess the fake / holdout data
#df <- clean_df(df, background_df)
## Exclude the variable nomem_encr if this variable is NOT in your model
#vars_without_id <- colnames(df)[colnames(df) != "nomem_encr"]
#
## Generate predictions from model
#predictions <- predict(model,
#                       subset(df, select = vars_without_id),
#                       type = "response")
#
## Create predictions that should be 0s and 1s rather than, e.g., probabilities
#predictions <- ifelse(predictions > 0.5, 1, 0)
#
## Output file should be data.frame with two columns, nomem_encr and predictions
#df_predict <- data.frame("nomem_encr" = df[ , "nomem_encr" ], "prediction" = predictions)
## Force columnnames (overrides names that may be given by `predict`)
#names(df_predict) <- c("nomem_encr", "prediction")
# Return only dataset with predictions and identifier
return( df_predict )
# load the fake data
fake <- data.table::fread("PreFer_fake_data.csv",
keepLeadingZeros = TRUE, # if FALSE adds zeroes to some dates
data.table = FALSE)
# apply the function to the fake data
predict_outcomes(fake)
train_save_model <- function(cleaned_df, outcome_df) {
# Trains a model using the cleaned dataframe and saves the model to a file.
# Parameters:
# cleaned_df (dataframe): The cleaned data from clean_df function to be used for training the model.
# outcome_df (dataframe): The data with the outcome variable (e.g., from PreFer_train_outcome.csv or PreFer_fake_outcome.csv).
# prepping our final fit model to be replace model.rds
model <- readRDS("best_final_fit.rds") %>% unbundle()
# Save the model
saveRDS(model, "model.rds")
}
clean_df <- function(df, background_df = NULL){
# Preprocess the input dataframe to feed the model.
### If no cleaning is done (e.g. if all the cleaning is done in a pipeline) leave only the "return df" command
return(df)
}
# training and saving the model
train_save_model(model_path = "best_final_fit.rds")
train_save_model <- function(model_path = "best_final_fit.rds") {
# Trains a model using the cleaned dataframe and saves the model to a file.
# Parameters:
# cleaned_df (dataframe): The cleaned data from clean_df function to be used for training the model.
# outcome_df (dataframe): The data with the outcome variable (e.g., from PreFer_train_outcome.csv or PreFer_fake_outcome.csv).
# prepping our final fit model to be replace model.rds
model <- readRDS(model_path) %>% unbundle()
# Save the model
saveRDS(model, "model.rds")
}
# training and saving the model
train_save_model(model_path = "best_final_fit.rds")
# load the fake data
fake <- data.table::fread("PreFer_fake_data.csv",
keepLeadingZeros = TRUE, # if FALSE adds zeroes to some dates
data.table = FALSE)
# apply the function to the fake data
predict_outcomes(fake)
predict_outcomes <- function(df, background_df = NULL, model_path = "model.rds"){
# Generate predictions using the saved model and the input dataframe.
# The predict_outcomes function accepts a dataframe as an argument
# and returns a new dataframe with two columns: nomem_encr and
# prediction. The nomem_encr column in the new dataframe replicates the
# corresponding column from the input dataframe The prediction
# column contains predictions for each corresponding nomem_encr. Each
# prediction is represented as a binary value: '0' indicates that the
# individual did not have a child during 2021-2023, while '1' implies that
# they did.
# Parameters:
# df (dataframe): The data dataframe for which predictions are to be made.
# background_df (dataframe): The background data dataframe for which predictions are to be made.
# model_path (str): The path to the saved model file (which is the output of training.R).
# Returns:
# dataframe: A dataframe containing the identifiers and their corresponding predictions.
## This script contains a bare minimum working example
if( !("nomem_encr" %in% colnames(df)) ) {
warning("The identifier variable 'nomem_encr' should be in the dataset")
}
# Load the model
model <- readRDS(model_path)
df_predict <- predict(model, df) %>%
bind_cols(df %>% select(nomem_encr)) %>%
select(nomem_encr, prediction = .pred_class)
# Preprocess the fake / holdout data
#df <- clean_df(df, background_df)
## Exclude the variable nomem_encr if this variable is NOT in your model
#vars_without_id <- colnames(df)[colnames(df) != "nomem_encr"]
#
## Generate predictions from model
#predictions <- predict(model,
#                       subset(df, select = vars_without_id),
#                       type = "response")
#
## Create predictions that should be 0s and 1s rather than, e.g., probabilities
#predictions <- ifelse(predictions > 0.5, 1, 0)
#
## Output file should be data.frame with two columns, nomem_encr and predictions
#df_predict <- data.frame("nomem_encr" = df[ , "nomem_encr" ], "prediction" = predictions)
## Force columnnames (overrides names that may be given by `predict`)
#names(df_predict) <- c("nomem_encr", "prediction")
# Return only dataset with predictions and identifier
return( df_predict )
}
# load the fake data
fake <- data.table::fread("PreFer_fake_data.csv",
keepLeadingZeros = TRUE, # if FALSE adds zeroes to some dates
data.table = FALSE)
# apply the function to the fake data
predict_outcomes(fake)
install.packages(c("dplyr","data.table","tidyr","tidyverse","here",
"tidymodels", "xgboost", "ranger", "bundle"), repos="https://cran.r-project.org", dependencies=TRUE)
install.packages(c("dplyr", "data.table", "tidyr", "tidyverse", "here", "tidymodels", "xgboost", "ranger", "bundle"), repos = "https://cran.r-project.org", dependencies = TRUE)
# load the fake data
fake <- data.table::fread("PreFer_fake_data.csv",
keepLeadingZeros = TRUE, # if FALSE adds zeroes to some dates
data.table = FALSE)
# apply the function to the fake data
predict_outcomes(fake)
